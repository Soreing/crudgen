package crudgen

import (
	"strconv"
	"text/template"
)

var funcMap = template.FuncMap{
	"sub":              sub,
	"listParam":        listParam,
	"listColumn":       listColumn,
	"listPlaceholder":  listPlaceholder,
	"listProperty":     listProperty,
	"listWhere":        listWhere,
	"listMatchBetween": listMatchBetween,
}

func sub(a, b int) int {
	return a - b
}

// Lists parameters of name and type separated by ", "
// If trailing is true, comma is added at the end too
func listParam(list []Attrib, trailing bool) string {
	str := ""
	for i := 0; i < len(list); i++ {
		str += list[i].Column + " " + list[i].Type
		if trailing || i < len(list)-1 {
			str += ", "
		}
	}

	return str
}

// Lists column names separated by ", "
// If trailing is true, comma is added at the end too
func listColumn(list []Attrib, trailing bool) string {
	str := ""
	for i := 0; i < len(list); i++ {
		str += list[i].Column
		if trailing || i < len(list)-1 {
			str += ", "
		}
	}

	return str
}

// Lists placeholders $1, $2 ... separated by ", "
// If trailing is true, comma is added at the end too
func listPlaceholder(list []Attrib, trailing bool) string {
	str := ""
	for i := 0; i < len(list); i++ {
		str += "$" + strconv.Itoa(list[i].Order)
		if trailing || i < len(list)-1 {
			str += ", "
		}
	}

	return str
}

// Lists object properties "base.x" separated by ", "
// If trailing is true, comma is added at the end too
func listProperty(list []Attrib, base string, trailing bool) string {
	str := ""
	for i := 0; i < len(list); i++ {
		str += base + "." + list[i].Name
		if trailing || i < len(list)-1 {
			str += ", "
		}
	}

	return str
}

// Lists WHERE conditions with $ placeholders separated by " AND "
func listWhere(list []Attrib) string {
	str := ""
	for i := 0; i < len(list); i++ {
		str += list[i].Column + " = $" + strconv.Itoa(list[i].Order)
		if i < len(list)-1 {
			str += " AND "
		}
	}

	return str
}

// Lists WHERE conditions for matching columns between table A and B
func listMatchBetween(list []Attrib, a string, b string) string {
	str := ""
	ad, bd := ".", "."
	if a == "" {
		ad = ""
	}
	if b == "" {
		bd = ""
	}

	for i := 0; i < len(list); i++ {
		str += a + ad + list[i].Column + " = " + b + bd + list[i].Column
		if i < len(list)-1 {
			str += " AND "
		}
	}

	return str
}

var pkgTemplate = template.Must(template.New("").Funcs(funcMap).Parse(`// Code generated by go generate; DO NOT EDIT.
{{- $lastPK := sub (len .PKeyFields) 1 -}}
{{- $lastIN := sub (len .InsertFields) 1 -}}
{{- $lastUP := sub (len .UpdateFields) 1 -}}
{{- define "WHERE_AND"}}{{$last := sub (len .) 1}}{{range $i, $e := . }}{{ $e.Column }}=${{ $e.Order }}{{if lt $i $last}} AND{{end}} {{end}}{{end}}
package {{.Package}}

import ( 
{{- range .Imports}}
	"{{.}}"
{{- end}}
)

type {{.InterfaceName}} interface {
	Create(obj {{.ModelTypeName}}) (*{{.ModelTypeName}}, error)
	Read({{listParam .PKeyFields false}}) (*{{.ModelTypeName}}, error)
	Update({{listParam .PKeyFields true}}obj {{.ModelTypeName}}) (*{{.ModelTypeName}}, error)
	Delete({{listParam .PKeyFields false}}) (error)
}

func (r *{{.RepoTypeName}}) Create(obj {{.ModelTypeName}}) (*{{.ModelTypeName}}, error) {
	rec := &{{.ModelTypeName}}{}
	err := r.db.Get(
		rec, ""+
			"INSERT INTO {{.TableName}}({{listColumn .InsertFields false}}) "+
			"VALUES({{listPlaceholder .InsertFields false}}) "+
			"RETURNING * ",
		{{listProperty .InsertFields "obj" true}}
	)

	if err != nil {
		return nil, err
	} else {
		return rec, nil
	}
} 

func (r *{{.RepoTypeName}}) Read({{listParam .PKeyFields false}}) (*{{.ModelTypeName}}, error) {
	rec := &{{.ModelTypeName}}{}
	err := r.db.Get(
		rec, ""+
			"SELECT * "+
			"FROM {{.TableName}} "+
			"WHERE {{listWhere .PKeyFields}}",
			{{listColumn .PKeyFields true}}
	)

	if err != nil {
		return nil, err
	} else {
		return rec, nil
	}
} 


func (r *{{.RepoTypeName}}) Update({{listParam .PKeyFields true}}obj {{.ModelTypeName}}) (*{{.ModelTypeName}}, error) {
	old := &{{.ModelTypeName}}{}
	err := r.db.Get(
		old, ""+
			"UPDATE {{.TableName}} SET "+
			{{- range $i, $e := .UpdateFields}}
			"  {{$e.Column}} = ${{$e.Order}}{{if lt $i $lastUP}},{{end}} "+
			{{- end}}
			"FROM (SELECT * FROM {{.TableName}} WHERE {{listWhere .PKeyFields}} FOR UPDATE) tb "+
			"WHERE {{listMatchBetween .PKeyFields .TableName "tb"}} "+
			"RETURNING tb.*",
			{{listColumn .PKeyFields true}}{{listProperty .UpdateFields "obj" true}}
	)

	if err != nil {
		return nil, err
	} else {
		return old, nil
	}
} 

func (r *{{.RepoTypeName}}) Delete({{listParam .PKeyFields false}}) (error) {
	_, err := r.db.Exec(""+
			"DELETE "+
			"FROM {{.TableName}} "+
			"WHERE {{listWhere .PKeyFields}}",
		{{listColumn .PKeyFields true}}
	)

	if err != nil {
		return err
	} else {
		return nil
	}
} 

`))
